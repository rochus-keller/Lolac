// Generated by OBNCPP 2019-04-09 on 2019-04-10T00:06:54
#include "LlLSS.h"
#include <memory>
using namespace Ll;

static std::auto_ptr<LSS> s_inst;

const int LSS::IdLen;
const int LSS::NofKeys;
const int LSS::null;
const int LSS::arrow;
const int LSS::times;
const int LSS::div;
const int LSS::and_;
const int LSS::plus;
const int LSS::minus;
const int LSS::or_;
const int LSS::xor_;
const int LSS::not_;
const int LSS::eql;
const int LSS::neq;
const int LSS::lss;
const int LSS::leq;
const int LSS::gtr;
const int LSS::geq;
const int LSS::at;
const int LSS::apo;
const int LSS::period;
const int LSS::comma;
const int LSS::colon;
const int LSS::rparen;
const int LSS::rbrak;
const int LSS::rbrace;
const int LSS::then;
const int LSS::lparen;
const int LSS::lbrak;
const int LSS::lbrace;
const int LSS::repl;
const int LSS::becomes;
const int LSS::integer_;
const int LSS::ident;
const int LSS::ts;
const int LSS::semicolon;
const int LSS::end;
const int LSS::const_;
const int LSS::type;
const int LSS::reg;
const int LSS::var;
const int LSS::out;
const int LSS::inout;
const int LSS::in;
const int LSS::begin;
const int LSS::module;
const int LSS::eof;

LSS* LSS::_inst()
{
	if( s_inst.get() == 0 )
		s_inst.reset( new LSS() );
	return s_inst.get();
}

void LSS::Mark(_ValArray<char> msg)
{
	// VAR
	int p;

	// BEGIN
	LSS* _this = _inst();
	p = Texts::_inst()->Pos(_this->R);
	if( p > _this->errpos + 2 )
	{
		Texts::_inst()->WriteString(_this->W, "  pos ");
		Texts::_inst()->WriteInt(_this->W, p, 1);
		Texts::_inst()->WriteString(_this->W, "  err:  ");
		Texts::_inst()->WriteString(_this->W, msg);
		Texts::_inst()->WriteLn(_this->W);
		Texts::_inst()->Append(Oberon::_inst()->Log, _this->W.buf);
	}
	_this->errpos = p;
	_this->error = true;
	// END
}

void LSS::identifier(int& sym)
{
	// VAR
	int i;

	// BEGIN
	LSS* _this = _inst();
	i = 0;
	do 
	{
		if( i < _this->IdLen )
		{
			_this->id[i] = _this->ch;
			i++;
		}
		Texts::_inst()->Read(_this->R, _this->ch);
	} while( !( (_this->ch < '0') || (_this->ch > '9') && (_this->ch < 'A') || (_this->ch > 'Z') && (_this->ch < 'a') || (_this->ch > 'z') ) );
	if( _this->ch == '\'' )
	{
		if( i < _this->IdLen )
		{
			_this->id[i] = _this->ch;
			i++;
		}
		Texts::_inst()->Read(_this->R, _this->ch);
	}
	if( i == _this->IdLen )
	{
		_this->Mark("ident too long");
		_this->id[_this->IdLen - 1] = 0x0;
	}else
		_this->id[i] = 0x0;

	i = 0;
	while( (i < _this->NofKeys) && (_this->id != _this->key[i]) )
		i++;
	
	if( i < _this->NofKeys )
		sym = _this->symno[i];
	else
		sym = _this->ident;

	// END
}

void LSS::Number(int& sym)
{
	// VAR
	int i;
	int k;
	int h;
	int n;
	int d;
	bool hex;
	_FxArray<int,16> dig;

	// BEGIN
	LSS* _this = _inst();
	sym = _this->integer_;
	i = 0;
	k = 0;
	n = 0;
	hex = false;
	do 
	{
		if( n < 16 )
		{
			d = int( _this->ch ) - 0x30;
			if( d >= 10 )
			{
				hex = true;
				d = d - 7;
			}
			dig[n] = d;
			n++;
		}else
		{
			_this->Mark("too many digits");
			n = 0;
		}
		Texts::_inst()->Read(_this->R, _this->ch);
	} while( !( (_this->ch < '0') || (_this->ch > '9') && (_this->ch < 'A') || (_this->ch > 'F') ) );
	/* hex */
	if( _this->ch == 'H' )
	{
		/* no overflow check */
		do 
		{
			h = dig[i];
			k = k * 0x10 + h;
			i++;
		} while( !( i == n ) );
		Texts::_inst()->Read(_this->R, _this->ch);
	}else
	{
		if( hex )
			_this->Mark("illegal hex digit");
		
		do 
		{
			k = k * 10 + dig[i];
			i++;
		} while( !( i == n ) );
	}
	_this->val = k;
	// END
}

void LSS::comment()
{
	// BEGIN
	LSS* _this = _inst();
	Texts::_inst()->Read(_this->R, _this->ch);
	do 
	{
		while( !_this->R.eot && (_this->ch != '*') )
			if( _this->ch == '(' )
			{
				Texts::_inst()->Read(_this->R, _this->ch);
				if( _this->ch == '*' )
					_this->comment();
				
			}else
				Texts::_inst()->Read(_this->R, _this->ch);

		
		while( _this->ch == '*' )
			Texts::_inst()->Read(_this->R, _this->ch);
		
	} while( !( (_this->ch == ')') || _this->R.eot ) );
	if( !_this->R.eot )
		Texts::_inst()->Read(_this->R, _this->ch);
	else
		_this->Mark("comment not terminated");

	// END
}

void LSS::Get(int& sym)
{
	// BEGIN
	LSS* _this = _inst();
	do 
	{
		while( !_this->R.eot && (_this->ch <= ' ') )
			Texts::_inst()->Read(_this->R, _this->ch);
		
		if( _this->R.eot )
			sym = _this->eof;
		else if( _this->ch < 'A' )
		{
			if( _this->ch < '0' )
			{
				if( _this->ch == '!' )
				{
					Texts::_inst()->Read(_this->R, _this->ch);
					sym = _this->repl;
				}else if( _this->ch == '#' )
				{
					Texts::_inst()->Read(_this->R, _this->ch);
					sym = _this->neq;
				}else if( _this->ch == '$' )
				{
					Texts::_inst()->Read(_this->R, _this->ch);
					sym = _this->null;
				}else if( _this->ch == '&' )
				{
					Texts::_inst()->Read(_this->R, _this->ch);
					sym = _this->and_;
				}else if( _this->ch == '\'' )
				{
					Texts::_inst()->Read(_this->R, _this->ch);
					sym = _this->apo;
				}else if( _this->ch == '(' )
				{
					Texts::_inst()->Read(_this->R, _this->ch);
					if( _this->ch == '*' )
					{
						sym = _this->null;
						_this->comment();
					}else
						sym = _this->lparen;

				}else if( _this->ch == ')' )
				{
					Texts::_inst()->Read(_this->R, _this->ch);
					sym = _this->rparen;
				}else if( _this->ch == '*' )
				{
					Texts::_inst()->Read(_this->R, _this->ch);
					sym = _this->times;
				}else if( _this->ch == '+' )
				{
					Texts::_inst()->Read(_this->R, _this->ch);
					sym = _this->plus;
				}else if( _this->ch == ',' )
				{
					Texts::_inst()->Read(_this->R, _this->ch);
					sym = _this->comma;
				}else if( _this->ch == '-' )
				{
					Texts::_inst()->Read(_this->R, _this->ch);
					if( _this->ch == '>' )
					{
						Texts::_inst()->Read(_this->R, _this->ch);
						sym = _this->then;
					}else
						sym = _this->minus;

				}else if( _this->ch == '.' )
				{
					Texts::_inst()->Read(_this->R, _this->ch);
					sym = _this->period;
				}else if( _this->ch == '/' )
				{
					Texts::_inst()->Read(_this->R, _this->ch);
					sym = _this->div;
				}else
					sym = _this->null;

			}else if( _this->ch <= '9' )
				_this->Number(sym);
			else if( _this->ch == ':' )
			{
				Texts::_inst()->Read(_this->R, _this->ch);
				if( _this->ch == '=' )
				{
					Texts::_inst()->Read(_this->R, _this->ch);
					sym = _this->becomes;
				}else
					sym = _this->colon;

			}else if( _this->ch == ';' )
			{
				Texts::_inst()->Read(_this->R, _this->ch);
				sym = _this->semicolon;
			}else if( _this->ch == '<' )
			{
				Texts::_inst()->Read(_this->R, _this->ch);
				if( _this->ch == '=' )
				{
					Texts::_inst()->Read(_this->R, _this->ch);
					sym = _this->leq;
				}else
					sym = _this->lss;

			}else if( _this->ch == '=' )
			{
				Texts::_inst()->Read(_this->R, _this->ch);
				sym = _this->eql;
			}else if( _this->ch == '>' )
			{
				Texts::_inst()->Read(_this->R, _this->ch);
				if( _this->ch == '=' )
				{
					Texts::_inst()->Read(_this->R, _this->ch);
					sym = _this->geq;
				}else
					sym = _this->gtr;

			}else if( _this->ch == '?' )
			{
				Texts::_inst()->Read(_this->R, _this->ch);
				sym = _this->then;
			}else if( _this->ch == '@' )
			{
				Texts::_inst()->Read(_this->R, _this->ch);
				sym = _this->at;
			}else
				sym = _this->null;

		}else if( _this->ch <= 'Z' )
			_this->identifier(sym);
		else if( _this->ch < 'a' )
		{
			if( _this->ch == '[' )
			{
				Texts::_inst()->Read(_this->R, _this->ch);
				sym = _this->lbrak;
			}else if( _this->ch == ']' )
			{
				Texts::_inst()->Read(_this->R, _this->ch);
				sym = _this->rbrak;
			}else if( _this->ch == '^' )
			{
				Texts::_inst()->Read(_this->R, _this->ch);
				sym = _this->xor_;
			}else
				sym = _this->null;

		}else if( _this->ch <= 'z' )
			_this->identifier(sym);
		else if( _this->ch <= '{' )
		{
			Texts::_inst()->Read(_this->R, _this->ch);
			sym = _this->lbrace;
		}else if( _this->ch <= '|' )
		{
			Texts::_inst()->Read(_this->R, _this->ch);
			sym = _this->or_;
		}else if( _this->ch <= '}' )
		{
			Texts::_inst()->Read(_this->R, _this->ch);
			sym = _this->rbrace;
		}else if( _this->ch <= '~' )
		{
			Texts::_inst()->Read(_this->R, _this->ch);
			sym = _this->not_;
		}else
			sym = _this->null;

	} while( !( sym != _this->null ) );
	// END
}

void LSS::Init(Texts::Text T, int pos)
{
	// BEGIN
	LSS* _this = _inst();
	_this->error = false;
	_this->errpos = pos;
	Texts::_inst()->OpenReader(_this->R, T, pos);
	Texts::_inst()->Read(_this->R, _this->ch);
	// END
}

LSS::LSS()
{
	// BEGIN
	Texts::_inst()->OpenWriter(W);
	key[0] = "BEGIN";
	symno[0] = begin;
	key[1] = "CONST";
	symno[1] = const_;
	key[2] = "END";
	symno[2] = end;
	key[3] = "IN";
	symno[3] = in;
	key[4] = "INOUT";
	symno[4] = inout;
	key[5] = "MODULE";
	symno[5] = module;
	key[6] = "OUT";
	symno[6] = out;
	key[7] = "REG";
	symno[7] = reg;
	key[8] = "TYPE";
	symno[8] = type;
	key[9] = "VAR";
	symno[9] = var;
	key[10] = "TS";
	symno[10] = ts;
	// END
}

LSS::~LSS()
{
	s_inst.release();
}

