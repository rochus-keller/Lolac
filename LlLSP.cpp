// Generated by OBNCPP 2019-04-09 on 2019-04-10T00:06:54
#include "LlLSP.h"
#include <memory>
using namespace Ll;

static std::auto_ptr<LSP> s_inst;


LSP* LSP::_inst()
{
	if( s_inst.get() == 0 )
		s_inst.reset( new LSP() );
	return s_inst.get();
}

void LSP::PrintType(LSB::Type typ)
{
	// VAR
	LSB::Object obj;

	// BEGIN
	LSP* _this = _inst();
	if( dynamic_cast<LSB::ArrayType>(typ) != 0  )
	{
		Texts::_inst()->Write(_this->W, '[');
		Texts::_inst()->WriteInt(_this->W, typ->len, 1);
		Texts::_inst()->Write(_this->W, ']');
		_this->PrintType(typ->_to<LSB::ArrayType>()->eltyp);
	}else if( dynamic_cast<LSB::UnitType>(typ) != 0  )
	{
		Texts::_inst()->WriteString(_this->W, "UnitType ");
		obj = typ->_to<LSB::UnitType>()->firstobj;
	}else
		Texts::_inst()->WriteString(_this->W, "BIT");

	Texts::_inst()->Append(Oberon::_inst()->Log, _this->W.buf);
	// END
}

void LSP::PrintTree(LSB::Item x, int n)
{
	// VAR
	int i;

	// BEGIN
	LSP* _this = _inst();
	if( x != 0 )
	{
		i = n;
		if( dynamic_cast<LSB::Object>(x) != 0  )
		{
			while( i > 0 )
			{
				Texts::_inst()->Write(_this->W, 0x9);
				i--;
			}
			Texts::_inst()->WriteString(_this->W, x->_to<LSB::Object>()->name);
			Texts::_inst()->WriteLn(_this->W);
		}else
		{
			_this->PrintTree(x->a, n + 1);
			while( i > 0 )
			{
				Texts::_inst()->Write(_this->W, 0x9);
				i--;
			}
			if( x->tag == LSB::_inst()->lit )
				Texts::_inst()->WriteInt(_this->W, x->val, 1);
			else
			{
				Texts::_inst()->WriteString(_this->W, _this->C[x->tag]);
			}
			Texts::_inst()->WriteLn(_this->W);
			_this->PrintTree(x->b, n + 1);
		}
	}
	// END
}

void LSP::PrintObj(LSB::Object obj, int n)
{
	// VAR
	LSB::Item apar;
	LSB::Object obj1;

	// BEGIN
	LSP* _this = _inst();
	if( n > 0 )
		Texts::_inst()->Write(_this->W, 0x9);
	
	Texts::_inst()->WriteString(_this->W, _this->C[obj->tag]);
	Texts::_inst()->Write(_this->W, ' ');
	Texts::_inst()->WriteString(_this->W, obj->name);
	Texts::_inst()->Append(Oberon::_inst()->Log, _this->W.buf);
	if( obj->tag == LSB::_inst()->const_ )
	{
		Texts::_inst()->WriteString(_this->W, " = ");
		_this->PrintTree(obj->b, 1);
		Texts::_inst()->WriteLn(_this->W);
	}else if( obj->tag == LSB::_inst()->typ )
	{
		/* formal param list */
		if( dynamic_cast<LSB::UnitType>(obj->type) != 0  )
		{
			obj1 = obj->type->_to<LSB::UnitType>()->firstobj;
			Texts::_inst()->WriteString(_this->W, " BEGIN ");
			Texts::_inst()->WriteLn(_this->W);
			while( (obj1 != 0) && (obj1 != LSB::_inst()->root) )
			{
				_this->PrintObj(obj1, 0);
				obj1 = obj1->next;
			}
			Texts::_inst()->WriteString(_this->W, "END");
			Texts::_inst()->WriteLn(_this->W);
		}else
			_this->PrintType(obj->type);

	}else
	{
		/* var */
		Texts::_inst()->WriteString(_this->W, ": ");
		if( dynamic_cast<LSB::UnitType>(obj->type) != 0  )
		{
			Texts::_inst()->WriteString(_this->W, obj->type->typobj->name);
			/* actual param list */
			apar = obj->b;
			Texts::_inst()->WriteString(_this->W, " [");
			while( apar != 0 )
			{
				_this->PrintTree(apar->b, 1);
				apar = apar->a;
			}
			Texts::_inst()->Write(_this->W, ']');
			Texts::_inst()->WriteLn(_this->W);
		}else
		{
			_this->PrintType(obj->type);
			Texts::_inst()->WriteString(_this->W, " #");
			Texts::_inst()->WriteInt(_this->W, obj->val, 1);
			if( obj->a != 0 )
			{
				/* indexed */
				if( obj->val == 0 )
					Texts::_inst()->WriteString(_this->W, " CLK");
				else if( obj->val == 1 )
					Texts::_inst()->WriteString(_this->W, " DEMUX");
				
				_this->PrintTree(obj->a, 1);
			}
			if( obj->b != 0 )
			{
				Texts::_inst()->WriteString(_this->W, " := ");
				Texts::_inst()->WriteLn(_this->W);
				_this->PrintTree(obj->b, 1);
			}else
				Texts::_inst()->WriteLn(_this->W);

		}
	}
	Texts::_inst()->Append(Oberon::_inst()->Log, _this->W.buf);
	// END
}

void LSP::List()
{
	// VAR
	LSB::Object obj;

	// BEGIN
	LSP* _this = _inst();
	obj = LSB::_inst()->top;
	Texts::_inst()->WriteString(_this->W, "listing ");
	Texts::_inst()->WriteString(_this->W, LSB::_inst()->modname);
	Texts::_inst()->WriteLn(_this->W);
	while( (obj != LSB::_inst()->root) && (obj != 0) )
	{
		_this->PrintObj(obj, 0);
		obj = obj->next;
	}
	Texts::_inst()->Append(Oberon::_inst()->Log, _this->W.buf);
	// END
}

LSP::LSP()
{
	// BEGIN
	Texts::_inst()->OpenWriter(W);
	C[LSB::_inst()->const_] = "CONST";
	C[LSB::_inst()->typ] = "TYPE";
	C[LSB::_inst()->var] = "VAR";
	C[LSB::_inst()->lit] = "LIT";
	C[LSB::_inst()->sel] = "MUX";
	C[LSB::_inst()->range] = ": ";
	C[LSB::_inst()->cons] = ", ";
	C[LSB::_inst()->repl] = "**";
	C[LSB::_inst()->or_] = "| ";
	C[LSB::_inst()->xor_] = "^ ";
	C[LSB::_inst()->and_] = "& ";
	C[LSB::_inst()->not_] = "~ ";
	C[LSB::_inst()->add] = "+ ";
	C[LSB::_inst()->sub] = "- ";
	C[LSB::_inst()->mul] = "* ";
	C[LSB::_inst()->div] = "/ ";
	C[LSB::_inst()->eql] = "= ";
	C[LSB::_inst()->neq] = "# ";
	C[LSB::_inst()->lss] = "< ";
	C[LSB::_inst()->geq] = ">=";
	C[LSB::_inst()->leq] = "<=";
	C[LSB::_inst()->gtr] = "> ";
	C[LSB::_inst()->then] = " -> ";
	C[LSB::_inst()->else_] = " :: ";
	C[LSB::_inst()->ts] = "TS ";
	C[LSB::_inst()->next] = "--";
	// END
}

LSP::~LSP()
{
	s_inst.release();
}

