// Generated by OBNCPP 2019-04-09 on 2019-04-10T00:06:54
// Modified by me@rochus-keller.ch on 2019-04-10

#include "LlLSC.h"
#include <memory>
using namespace Ll;

static std::auto_ptr<LSC> s_inst;


LSC* LSC::_inst()
{
	if( s_inst.get() == 0 )
		s_inst.reset( new LSC() );
	return s_inst.get();
}

void LSC::Err(int n)
{
	// BEGIN
	LSC* _this = _inst();
	LSS::_inst()->Mark("type error");
	Texts::_inst()->WriteInt(_this->W, n, 4);
	Texts::_inst()->WriteLn(_this->W);
	Texts::_inst()->Append(Oberon::_inst()->Log, _this->W.buf);
	// END
}

int LSC::Log(int m)
{
	// VAR
	int n;

	// BEGIN
	LSC* _this = _inst();
	n = 1;
	while( m > 1 )
	{
		m = m / 2;
		n++;
	}
	return n;
	// END
}

LSB::Item LSC::New(int tag, LSB::Item a, LSB::Item b)
{
	// VAR
	LSB::Item z;

	// BEGIN
	LSC* _this = _inst();
	z = new LSB::ItemDesc();
	z->tag = tag;
	z->a = a;
	z->b = b;
	z->val = b->val;
	return z;
	// END
}

/* insert at end, before BIT */
LSB::Object LSC::NewObj(int class_)
{
	// VAR
	LSB::Object new_;
	LSB::Object x;

	// BEGIN
	LSC* _this = _inst();
	x = _this->top;
	while( (x->next != _this->bot) && (x->next->name != LSS::_inst()->id) )
		x = x->next;
	
	if( x->next == _this->bot )
	{
		new_ = new LSB::ObjDesc();
		new_->name = LSS::_inst()->id;
		new_->tag = class_;
		new_->next = _this->bot;
		x->next = new_;
	}else
	{
		LSS::_inst()->Mark("mult def");
		new_ = x;
	}
	return new_;
	// END
}

/* find object with name = identifier last read */
LSB::Object LSC::ThisObj(_ValArray<char> id)
{
	// VAR
	LSB::Object x;

	// BEGIN
	LSC* _this = _inst();
	x = _this->top->next;
	while( (x != 0) && (x->name != id) )
		x = x->next;
	
	if( x == 0 )
	{
		LSS::_inst()->Mark("undef");
		x = _this->undef;
	}
	return x;
	// END
}

/* z.type = result type */
void LSC::CheckTypes(LSB::Item x, LSB::Item y, LSB::Item z)
{
	// VAR
	LSB::Type xtyp;
	LSB::Type ytyp;

	// BEGIN
	LSC* _this = _inst();
	xtyp = x->type;
	ytyp = y->type;
	z->type = xtyp;
	z->size = x->size;
	z->val = x->val;
	if( xtyp == LSB::_inst()->bitType )
	{
		/*  b + 0  */
		if( ytyp == LSB::_inst()->integer_ )
		{
			if( y->val >= 2 )
			{
				_this->Err(20);
				LSS::_inst()->Mark("only 0 or 1");
			}
		}else if( ytyp == LSB::_inst()->string )
			/*  b + {...}  */
			_this->Err(21);
		else if( ytyp != LSB::_inst()->bitType )
			_this->Err(22);
		
	}else if( dynamic_cast<LSB::ArrayType>(xtyp) != 0  )
	{
		if( xtyp->_to<LSB::ArrayType>()->eltyp == LSB::_inst()->bitType )
		{
			if( (dynamic_cast<LSB::ArrayType>(ytyp) != 0 ) && (xtyp->_to<LSB::ArrayType>()->eltyp == LSB::_inst()->bitType) )
			{
				/*  x + y  */
				if( xtyp->size != ytyp->size )
					_this->Err(33);
				
			}else if( ytyp == LSB::_inst()->integer_ )
			{
				/*  w + 5  */
				if( xtyp->size < _this->Log(y->val) )
					_this->Err(30);
				
			}else if( ytyp == LSB::_inst()->string )
			{
				/* x + {...}  */
				if( xtyp->size != y->size )
					_this->Err(31);
				
			}else
				_this->Err(34);

		}else if( (dynamic_cast<LSB::ArrayType>(ytyp) != 0 ) && (xtyp->_to<LSB::ArrayType>()->eltyp == ytyp->_to<LSB::ArrayType>()->eltyp) )
		{
			if( (xtyp->size != ytyp->size) )
				_this->Err(40);
			
		}else
			_this->Err(41);

	}else if( xtyp == LSB::_inst()->string )
	{
		/*  {...} + b  */
		if( ytyp == LSB::_inst()->bitType )
			_this->Err(12);
		else if( (dynamic_cast<LSB::ArrayType>(ytyp) != 0 ) && (ytyp->_to<LSB::ArrayType>()->eltyp == LSB::_inst()->bitType) )
		{
			/*  {...} + w  */
			if( x->size != ytyp->size )
				_this->Err(13);
			
		}else if( ytyp == LSB::_inst()->integer_ )
		{
			/*  {...} + 5 */
			if( x->size < _this->Log(y->val) )
				_this->Err(10);
			
		}else if( ytyp == LSB::_inst()->string )
		{
			/*  {...} + {...}  */
			if( x->size != y->size )
				_this->Err(11);
			
		}else
			_this->Err(14);

	}else if( xtyp == LSB::_inst()->integer_ )
	{
		/*  5 + w  */
		if( (dynamic_cast<LSB::ArrayType>(ytyp) != 0 ) && (ytyp->_to<LSB::ArrayType>()->eltyp == LSB::_inst()->bitType) )
		{
			if( _this->Log(x->val) > ytyp->size )
			{
				_this->Err(3);
				LSS::_inst()->Mark("const too large");
			}
		}else if( ytyp == LSB::_inst()->bitType )
		{
			/*  5 + b  */
			if( x->val >= 2 )
				_this->Err(2);
			
		}else if( ytyp == LSB::_inst()->integer_ )
			; // empty statement
		else if( ytyp == LSB::_inst()->string )
		{
			/*  5 + 5  */
			/*  5 + {...}  */
			if( _this->Log(x->val) > y->size )
				_this->Err(12);
			
		}else
			_this->Err(4);

	}
	// END
}

void LSC::selector(LSB::Item& x)
{
	// VAR
	LSB::Item y;
	LSB::Item z;
	LSB::Object obj;
	LSB::Type eltyp;
	int len;
	int kind;

	// BEGIN
	LSC* _this = _inst();
	while( (_this->sym == LSS::_inst()->lbrak) || (_this->sym == LSS::_inst()->period) )
		if( _this->sym == LSS::_inst()->lbrak )
		{
            eltyp = x->type->_to<LSB::ArrayType>()->eltyp;
			LSS::_inst()->Get(_this->sym);
			_this->expression(y);
			/* range */
			if( _this->sym == LSS::_inst()->colon )
			{
				LSS::_inst()->Get(_this->sym);
				_this->expression(z);
				if( (y->tag == LSB::_inst()->lit) && (z->tag == LSB::_inst()->lit) )
				{
					len = y->val - z->val + 1;
					y = _this->New(LSB::_inst()->range, y, z);
					x = _this->New(LSB::_inst()->sel, x, y);
					x->type = LSB::_inst()->string;
					x->size = len;
				}
			}else
			{
				kind = x->val;
				x = _this->New(LSB::_inst()->sel, x, y);
				x->type = eltyp;
				x->val = kind;
			}
			if( _this->sym == LSS::_inst()->rbrak )
				LSS::_inst()->Get(_this->sym);
			else
				LSS::_inst()->Mark("rbrak ?");

		}else
		{
			/* sym = LSS.period */
			LSS::_inst()->Get(_this->sym);
			_this->factor(y);
			if( (y->tag == LSB::_inst()->lit) && (y->val >= x->type->len) )
				LSS::_inst()->Mark("too large");
			
			eltyp = x->type->_to<LSB::ArrayType>()->eltyp;
			kind = x->val;
			x = _this->New(LSB::_inst()->sel, x, y);
			x->type = eltyp;
			x->val = kind;
		}
	
	// END
}

void LSC::elem(LSB::Item& x, int& len)
{
	// VAR
	LSB::Item y;
	LSB::Item z;
	int m;
	int n;

	// BEGIN
	LSC* _this = _inst();
	_this->expression(x);
	if( (x->type == LSB::_inst()->integer_) || (x->type == LSB::_inst()->string) )
		m = x->size;
	else
		m = x->type->size;

	if( _this->sym == LSS::_inst()->repl )
	{
		LSS::_inst()->Get(_this->sym);
		if( _this->sym == LSS::_inst()->integer_ )
		{
			y = new LSB::ItemDesc();
			y->tag = LSB::_inst()->lit;
			n = LSS::_inst()->val;
			y->val = n;
			y->type = LSB::_inst()->integer_;
			LSS::_inst()->Get(_this->sym);
			x = _this->New(LSB::_inst()->repl, x, y);
		}
	}else
		n = 1;

	len = m * n;
	// END
}

void LSC::constructor_(LSB::Item& x)
{
	// VAR
	LSB::Item y;
	int n;
	int len;

	// BEGIN
	LSC* _this = _inst();
	_this->elem(x, len);
	while( _this->sym == LSS::_inst()->comma )
	{
		LSS::_inst()->Get(_this->sym);
		_this->elem(y, n);
		len += n;
		x = _this->New(LSB::_inst()->cons, x, y);
		x->val = len;
	}
	x->size = len;
	x->type = LSB::_inst()->string;
	if( _this->sym == LSS::_inst()->rbrace )
		LSS::_inst()->Get(_this->sym);
	else
		LSS::_inst()->Mark("rbrace ?");

	// END
}

void LSC::factor0(LSB::Item& x)
{
	// VAR
	LSB::Object obj;
	LSB::Item y;
	LSB::Item z;
	int n;
	int len;
	LSB::ArrayType t;

	// BEGIN
	LSC* _this = _inst();
	if( _this->sym == LSS::_inst()->ident )
	{
		x = _this->ThisObj(LSS::_inst()->id);
		LSS::_inst()->Get(_this->sym);
		if( x->tag == LSB::_inst()->var )
			_this->selector(x);
		else if( x->tag == LSB::_inst()->const_ )
		{
			n = x->b->val;
			x = new LSB::ItemDesc();
			x->tag = LSB::_inst()->lit;
			x->val = n;
			x->type = LSB::_inst()->integer_;
		}else
			LSS::_inst()->Mark("bad factor");

	}else if( _this->sym == LSS::_inst()->lparen )
	{
		LSS::_inst()->Get(_this->sym);
		_this->expression(x);
		if( _this->sym == LSS::_inst()->rparen )
			LSS::_inst()->Get(_this->sym);
		else
			LSS::_inst()->Mark("rparen ?");

	}else if( _this->sym == LSS::_inst()->integer_ )
	{
		x = new LSB::ItemDesc();
		x->tag = LSB::_inst()->lit;
		x->val = LSS::_inst()->val;
		x->type = LSB::_inst()->integer_;
		LSS::_inst()->Get(_this->sym);
		if( _this->sym == LSS::_inst()->apo )
		{
			LSS::_inst()->Get(_this->sym);
			if( _this->sym == LSS::_inst()->integer_ )
			{
				len = LSS::_inst()->val;
				LSS::_inst()->Get(_this->sym);
				if( len < _this->Log(x->val) )
					LSS::_inst()->Mark("value too large");
				
			}else
			{
				LSS::_inst()->Mark("integer ?");
				len = 0;
			}
		}else
			len = 0;

		x->size = len;
	}else if( _this->sym == LSS::_inst()->not_ )
	{
		LSS::_inst()->Get(_this->sym);
		_this->factor(x);
		y = _this->New(LSB::_inst()->not_, 0, x);
		y->type = x->type;
		y->size = x->size;
		x = y;
	}else if( _this->sym == LSS::_inst()->lbrace )
	{
		LSS::_inst()->Get(_this->sym);
		_this->constructor_(x);
	}else
		LSS::_inst()->Mark("bad factor");

	// END
}

void LSC::term(LSB::Item& x)
{
	// VAR
	LSB::Item y;
	LSB::Item z;
	int op;

	// BEGIN
	LSC* _this = _inst();
	_this->factor(x);
	while( (_this->sym >= LSS::_inst()->times) && (_this->sym <= LSS::_inst()->and_) )
	{
		if( _this->sym == LSS::_inst()->and_ )
			op = LSB::_inst()->and_;
		else if( _this->sym == LSS::_inst()->times )
			op = LSB::_inst()->mul;
		else if( _this->sym == LSS::_inst()->div )
			op = LSB::_inst()->div;
		
		LSS::_inst()->Get(_this->sym);
		_this->factor(y);
		z = _this->New(op, x, y);
		_this->CheckTypes(x, y, z);
		x = z;
	}
	// END
}

void LSC::SimpleExpression(LSB::Item& x)
{
	// VAR
	LSB::Item y;
	LSB::Item z;
	int op;

	// BEGIN
	LSC* _this = _inst();
	if( _this->sym == LSS::_inst()->minus )
	{
		LSS::_inst()->Get(_this->sym);
		_this->term(y);
		if( y->tag == LSB::_inst()->lit )
		{
			x = y;
			x->val = -y->val;
		}else
		{
			x = _this->New(LSB::_inst()->sub, 0, y);
			x->type = y->type;
			x->size = y->size;
		}
	}else if( _this->sym == LSS::_inst()->plus )
	{
		LSS::_inst()->Get(_this->sym);
		_this->term(x);
	}else
		_this->term(x);

	while( (_this->sym >= LSS::_inst()->plus) && (_this->sym <= LSS::_inst()->xor_) )
	{
		if( _this->sym == LSS::_inst()->or_ )
			op = LSB::_inst()->or_;
		else if( _this->sym == LSS::_inst()->xor_ )
			op = LSB::_inst()->xor_;
		else if( _this->sym == LSS::_inst()->plus )
			op = LSB::_inst()->add;
		else if( _this->sym == LSS::_inst()->minus )
			op = LSB::_inst()->sub;
		
		LSS::_inst()->Get(_this->sym);
		_this->term(y);
		z = _this->New(op, x, y);
		_this->CheckTypes(x, y, z);
		x = z;
	}
	// END
}

void LSC::UncondExpression(LSB::Item& x)
{
	// VAR
	LSB::Item y;
	LSB::Item z;
	int rel;

	// BEGIN
	LSC* _this = _inst();
	_this->SimpleExpression(x);
	if( (_this->sym >= LSS::_inst()->eql) && (_this->sym <= LSS::_inst()->geq) )
	{
		if( _this->sym == LSS::_inst()->eql )
			rel = LSB::_inst()->eql;
		else if( _this->sym == LSS::_inst()->neq )
			rel = LSB::_inst()->neq;
		else if( _this->sym == LSS::_inst()->lss )
			rel = LSB::_inst()->lss;
		else if( _this->sym == LSS::_inst()->geq )
			rel = LSB::_inst()->geq;
		else if( _this->sym == LSS::_inst()->leq )
			rel = LSB::_inst()->leq;
		else
			rel = LSB::_inst()->gtr;

		LSS::_inst()->Get(_this->sym);
		_this->SimpleExpression(y);
		z = _this->New(rel, x, y);
		_this->CheckTypes(x, y, z);
		z->type = LSB::_inst()->bitType;
		x = z;
	}
	// END
}

void LSC::expression0(LSB::Item& x)
{
	// VAR
	LSB::Item y;
	LSB::Item z;
	LSB::Item w;

	// BEGIN
	LSC* _this = _inst();
	_this->UncondExpression(x);
	if( _this->sym == LSS::_inst()->then )
	{
		if( x->type != LSB::_inst()->bitType )
			LSS::_inst()->Mark("Boolean?");
		
		LSS::_inst()->Get(_this->sym);
		_this->expression(y);
		if( _this->sym == LSS::_inst()->colon )
		{
			LSS::_inst()->Get(_this->sym);
			_this->expression(z);
			w = _this->New(LSB::_inst()->else_, y, z);
			_this->CheckTypes(y, z, w);
			x = _this->New(LSB::_inst()->then, x, w);
			x->type = w->type;
			x->size = w->size;
		}else
			LSS::_inst()->Mark("colon ?");

	}
	// END
}

void LSC::CheckAssign(LSB::Item x, LSB::Item y)
{
	// VAR
	LSB::Type xtyp;
	LSB::Type ytyp;

	// BEGIN
	LSC* _this = _inst();
	xtyp = x->type;
	ytyp = y->type;
	if( xtyp != ytyp )
	{
		if( xtyp == LSB::_inst()->bitType )
		{
			if( (ytyp != LSB::_inst()->integer_) || (y->val >= 2) )
			{
				_this->Err(70);
			}
		}else if( dynamic_cast<LSB::ArrayType>(xtyp) != 0  )
		{
			if( xtyp->_to<LSB::ArrayType>()->eltyp == LSB::_inst()->bitType )
			{
				/* w := w */
				if( (dynamic_cast<LSB::ArrayType>(ytyp) != 0 ) && (xtyp->_to<LSB::ArrayType>()->eltyp == LSB::_inst()->bitType) )
				{
					/*  x + y  */
					if( xtyp->size != ytyp->size )
						_this->Err(71);
					
				}else if( ytyp == LSB::_inst()->integer_ )
				{
					/*  w := 5  */
					if( xtyp->size < _this->Log(y->val) )
						_this->Err(72);
					
				}else if( ytyp == LSB::_inst()->string )
				{
					/*  w := {...}  */
					if( xtyp->size != y->size )
						_this->Err(73);
					
				}else
					_this->Err(74);

			}else
				_this->Err(74);

		}
	}
	// END
}

void LSC::Param(LSB::Object fpar, LSB::Item& apar)
{
	// VAR
	LSB::Item y;
	LSB::Item z;

	// BEGIN
	LSC* _this = _inst();
	_this->expression(y);
	apar = _this->New(LSB::_inst()->next, 0, y);
	_this->CheckAssign(fpar, y);
	/* OUT or INOUT parameter */
	if( ( _Set() + (3) ).contains( fpar->val ) )
	{
		/* actual param is expression? */
		if( !(( _Set() + (3) ).contains( y->tag )) )
			LSS::_inst()->Mark("bad actual param");
		else if( y->b == 0 )
			y->b = _this->undef;
		
	}
	// END
}

void LSC::Statement()
{
	// VAR
	LSB::Item x;
	LSB::Item y;
	LSB::Item z;
	LSB::Item w;
	LSB::Item apar;
	LSB::Item npar;
	LSB::UnitType unit;
	LSB::Object fpar;

	// BEGIN
	LSC* _this = _inst();
	if( _this->sym < LSS::_inst()->ident )
	{
		LSS::_inst()->Mark("bad factor");
		do 
		{
			LSS::_inst()->Get(_this->sym);
		} while( !( _this->sym >= LSS::_inst()->ident ) );
	}
	if( _this->sym == LSS::_inst()->ident )
	{
		x = _this->ThisObj(LSS::_inst()->id);
		z = x;
		LSS::_inst()->Get(_this->sym);
		_this->selector(z);
		if( _this->sym == LSS::_inst()->becomes )
		{
			LSS::_inst()->Get(_this->sym);
			if( x->val >= 5 )
				LSS::_inst()->Mark("assignment to read-only");
			
			if( (x->b != 0) && !(dynamic_cast<LSB::ArrayType>(x->type) != 0 ) )
				LSS::_inst()->Mark("mult assign");
			
			/* tricky */
			_this->expression(y);
			_this->CheckAssign(z, y);
			x->b = y;
			/* overwriting clk field x.a  */
			if( z != x )
			{
				x->a = z->b;
				x->val = 1;
			}
		}else if( _this->sym == LSS::_inst()->lparen )
		{
			/* unit instantiation */
			LSS::_inst()->Get(_this->sym);
			if( dynamic_cast<LSB::UnitType>(x->type) != 0  )
			{
				unit = x->type->_to<LSB::UnitType>();
				fpar = unit->firstobj;
				if( _this->sym != LSS::_inst()->rparen )
				{
					_this->Param(fpar, apar);
					x->b = apar;
					fpar = fpar->next;
					while( _this->sym != LSS::_inst()->rparen )
					{
						if( _this->sym == LSS::_inst()->comma )
							LSS::_inst()->Get(_this->sym);
						
						_this->Param(fpar, npar);
						if( fpar->tag >= 3 )
						{
							fpar = fpar->next;
							apar->a = npar;
							apar = npar;
						}else
							LSS::_inst()->Mark("too many params");

					}
					if( fpar->val >= 3 )
						LSS::_inst()->Mark("too few params");
					
				}
				if( _this->sym == LSS::_inst()->rparen )
					LSS::_inst()->Get(_this->sym);
				else
					LSS::_inst()->Mark("rparen ?");

			}else
				LSS::_inst()->Mark("not a module");

		}else
			LSS::_inst()->Mark("bad statement");

	}else if( _this->sym == LSS::_inst()->ts )
	{
		/* tri-state */
		LSS::_inst()->Get(_this->sym);
		if( _this->sym == LSS::_inst()->lparen )
			LSS::_inst()->Get(_this->sym);
		else
			LSS::_inst()->Mark("( missing");

		if( _this->sym == LSS::_inst()->ident )
		{
			/* INOUT parameter */
			x = _this->ThisObj(LSS::_inst()->id);
			x->b = _this->undef;
			if( x->val != 5 )
				LSS::_inst()->Mark("not INOUT");
			
			LSS::_inst()->Get(_this->sym);
			if( _this->sym == LSS::_inst()->comma )
				LSS::_inst()->Get(_this->sym);
			
			/* output from gate */
			if( _this->sym == LSS::_inst()->ident )
			{
				y = _this->ThisObj(LSS::_inst()->id);
				_this->CheckAssign(x, y);
				y->b = _this->undef;
			}
			LSS::_inst()->Get(_this->sym);
			if( _this->sym == LSS::_inst()->comma )
				LSS::_inst()->Get(_this->sym);
			
			_this->expression(z);
			if( (z->tag == LSB::_inst()->lit) && (z->val <= 1) )
				z->type = LSB::_inst()->bitType;
			
			_this->CheckAssign(x, z);
			LSS::_inst()->Get(_this->sym);
			if( _this->sym == LSS::_inst()->comma )
				LSS::_inst()->Get(_this->sym);
			
			/* control */
			_this->expression(w);
			if( w->type != LSB::_inst()->bitType )
				_this->CheckAssign(x, w);
			
			w = _this->New(LSB::_inst()->next, z, w);
			x->b = _this->New(LSB::_inst()->ts, y, w);
			if( _this->sym == LSS::_inst()->rparen )
				LSS::_inst()->Get(_this->sym);
			else
				LSS::_inst()->Mark(") missing");

		}
	}
	// END
}

void LSC::StatSequence()
{
	// BEGIN
	LSC* _this = _inst();
	_this->Statement();
	while( _this->sym <= LSS::_inst()->semicolon )
	{
		if( _this->sym < LSS::_inst()->semicolon )
			LSS::_inst()->Mark("semicolon missing?");
		
		while( _this->sym == LSS::_inst()->semicolon )
			LSS::_inst()->Get(_this->sym);
		
		_this->Statement();
	}
	if( _this->sym == LSS::_inst()->end )
		LSS::_inst()->Get(_this->sym);
	else
		LSS::_inst()->Mark("END ?");

	// END
}

/* --------------------------------------------------- */
/*  for variables and registers,, obj.val has the meaning
    0  register
    1  --
    2  variable
    3  output parameter
    4  --
    5  inout parameter
    6  input parameter   */
void LSC::ConstDeclaration()
{
	// VAR
	LSB::Object obj;

	// BEGIN
	LSC* _this = _inst();
	if( _this->sym == LSS::_inst()->ident )
	{
		obj = _this->NewObj(LSB::_inst()->const_);
		LSS::_inst()->Get(_this->sym);
		if( (_this->sym == LSS::_inst()->becomes) || (_this->sym == LSS::_inst()->eql) )
			LSS::_inst()->Get(_this->sym);
		else
			LSS::_inst()->Mark(":= ?");

		_this->expression(obj->b);
		obj->type = LSB::_inst()->integer_;
		if( _this->sym == LSS::_inst()->semicolon )
			LSS::_inst()->Get(_this->sym);
		else
			LSS::_inst()->Mark("semicolon ?");

	}else
		LSS::_inst()->Mark("ident ?");

	// END
}

void LSC::Type0(LSB::Type& type)
{
	// VAR
	LSB::Object obj;
	int len;
	int size;
	LSB::Type eltyp;
	LSB::ArrayType arrtyp;

	// BEGIN
	LSC* _this = _inst();
	len = 1;
	/* array */
	if( _this->sym == LSS::_inst()->lbrak )
	{
		LSS::_inst()->Get(_this->sym);
		if( _this->sym == LSS::_inst()->integer_ )
		{
			len = LSS::_inst()->val;
			LSS::_inst()->Get(_this->sym);
		}else if( _this->sym == LSS::_inst()->ident )
		{
			obj = _this->ThisObj(LSS::_inst()->id);
			len = obj->val;
		}
		if( _this->sym == LSS::_inst()->rbrak )
			LSS::_inst()->Get(_this->sym);
		else
			LSS::_inst()->Mark("rbrak ?");

		_this->Type0(eltyp);
		arrtyp = new LSB::ArrayTypeDesc();
		size = eltyp->size * len;
		arrtyp->eltyp = eltyp;
		type = arrtyp;
		type->len = len;
		type->size = size;
	}else if( _this->sym == LSS::_inst()->ident )
	{
		obj = _this->ThisObj(LSS::_inst()->id);
		LSS::_inst()->Get(_this->sym);
		if( obj != 0 )
		{
			if( obj->tag == LSB::_inst()->typ )
				type = obj->type;
			else
			{
				LSS::_inst()->Mark("not a type");
				type = LSB::_inst()->bitType;
			}
		}else
			LSS::_inst()->Mark("type ?");

	}else
	{
		type = LSB::_inst()->bitType;
		LSS::_inst()->Mark("ident or [");
	}
	// END
}

void LSC::TypeDeclaration()
{
	// VAR
	LSB::Object obj;
	LSB::UnitType utyp;

	// BEGIN
	LSC* _this = _inst();
	if( _this->sym == LSS::_inst()->ident )
	{
		obj = _this->NewObj(LSB::_inst()->typ);
		LSS::_inst()->Get(_this->sym);
		if( (_this->sym == LSS::_inst()->becomes) || (_this->sym == LSS::_inst()->eql) )
			LSS::_inst()->Get(_this->sym);
		else
			LSS::_inst()->Mark(":= ?");

		if( _this->sym == LSS::_inst()->module )
		{
			LSS::_inst()->Get(_this->sym);
			utyp = new LSB::UnitTypeDesc();
			_this->Unit(utyp->firstobj);
			obj->type = utyp;
			obj->type->typobj = obj;
		}else
			_this->Type0(obj->type);

		if( _this->sym == LSS::_inst()->semicolon )
			LSS::_inst()->Get(_this->sym);
		else
			LSS::_inst()->Mark("semicolon ?");

	}else
		LSS::_inst()->Mark("ident ?");

	// END
}

void LSC::VarList(int kind, LSB::Item clk)
{
	// VAR
	LSB::Object first;
	LSB::Object new_;
	LSB::Object obj;
	LSB::Type type;

	// BEGIN
	LSC* _this = _inst();
	obj = 0;
	while( _this->sym == LSS::_inst()->ident )
	{
		new_ = _this->NewObj(LSB::_inst()->var);
		new_->name = LSS::_inst()->id;
		new_->val = kind;
		first = new_;
		LSS::_inst()->Get(_this->sym);
		if( _this->sym == LSS::_inst()->comma )
			LSS::_inst()->Get(_this->sym);
		else if( _this->sym == LSS::_inst()->ident )
			LSS::_inst()->Mark("comma missing");
		
		while( _this->sym == LSS::_inst()->ident )
		{
			new_ = _this->NewObj(LSB::_inst()->var);
			new_->name = LSS::_inst()->id;
			new_->val = kind;
			LSS::_inst()->Get(_this->sym);
			if( _this->sym == LSS::_inst()->comma )
				LSS::_inst()->Get(_this->sym);
			else if( _this->sym == LSS::_inst()->ident )
				LSS::_inst()->Mark("comma missing");
			
		}
		if( _this->sym == LSS::_inst()->colon )
		{
			LSS::_inst()->Get(_this->sym);
			_this->Type0(type);
			obj = first;
			while( obj != _this->bot )
			{
				obj->type = type;
				obj->a = clk;
				obj = obj->next;
			}
		}else
			LSS::_inst()->Mark("colon ?");

		if( _this->sym == LSS::_inst()->semicolon )
			LSS::_inst()->Get(_this->sym);
		else if( _this->sym != LSS::_inst()->rparen )
			LSS::_inst()->Mark("semicolon or rparen missing");
		
	}
	// END
}

void LSC::ParamList()
{
	// VAR
	int kind;

	// BEGIN
	LSC* _this = _inst();
	if( _this->sym == LSS::_inst()->in )
	{
		LSS::_inst()->Get(_this->sym);
		kind = 6;
	}else if( _this->sym == LSS::_inst()->out )
	{
		LSS::_inst()->Get(_this->sym);
		kind = 3;
	}else if( _this->sym == LSS::_inst()->inout )
	{
		LSS::_inst()->Get(_this->sym);
		kind = 5;
	}
	_this->VarList(kind, 0);
	// END
}

void LSC::Traverse(LSB::Item x)
{
	// BEGIN
	LSC* _this = _inst();
	if( x != 0 )
	{
		if( dynamic_cast<LSB::Object>(x) != 0  )
		{
			/* not reg */
			if( (x->tag == LSB::_inst()->var) && (x->val >= 2) )
			{
				/* loop */
				if( x->_to<LSB::Object>()->marked )
				{
					Texts::_inst()->WriteString(_this->W, x->_to<LSB::Object>()->name);
					Texts::_inst()->Write(_this->W, ' ');
					_this->err = true;
				}else if( x->b != 0 )
				{
					x->_to<LSB::Object>()->marked = true;
					_this->Traverse(x->b);
				}
				x->_to<LSB::Object>()->marked = false;
			}
		}else
		{
			_this->Traverse(x->a);
			_this->Traverse(x->b);
		}
	}
	// END
}

void LSC::Unit0(LSB::Object& locals)
{
	// VAR
	LSB::Object obj;
	LSB::Object oldtop;
	int kind;
	LSB::Item clock;

	// BEGIN
	LSC* _this = _inst();
	/* top is dummy */
	oldtop = _this->top->next;
	_this->top->next = LSB::_inst()->root;
	if( _this->sym == LSS::_inst()->lparen )
		LSS::_inst()->Get(_this->sym);
	else
		LSS::_inst()->Mark("lparen ?");

	while( (_this->sym == LSS::_inst()->in) || (_this->sym == LSS::_inst()->out) || (_this->sym == LSS::_inst()->inout) )
		_this->ParamList();
	
	if( _this->sym == LSS::_inst()->rparen )
		LSS::_inst()->Get(_this->sym);
	else
		LSS::_inst()->Mark("rparen ?");

	/* arrow */
	if( _this->sym == LSS::_inst()->xor_ )
	{
		LSS::_inst()->Get(_this->sym);
		locals = _this->top->next;
	}else
	{
		if( _this->sym == LSS::_inst()->semicolon )
			LSS::_inst()->Get(_this->sym);
		else
			LSS::_inst()->Mark("semicolon ?");

		if( _this->sym == LSS::_inst()->const_ )
		{
			LSS::_inst()->Get(_this->sym);
			while( _this->sym == LSS::_inst()->ident )
				_this->ConstDeclaration();
			
		}
		if( _this->sym == LSS::_inst()->type )
		{
			LSS::_inst()->Get(_this->sym);
			while( _this->sym == LSS::_inst()->ident )
				_this->TypeDeclaration();
			
		}
		while( (_this->sym == LSS::_inst()->var) || (_this->sym == LSS::_inst()->reg) )
			if( _this->sym == LSS::_inst()->var )
			{
				LSS::_inst()->Get(_this->sym);
				while( _this->sym == LSS::_inst()->ident )
					_this->VarList(2, 0);
				
			}else
			{
				/* reg */
				kind = 0;
				LSS::_inst()->Get(_this->sym);
				/* clock */
				if( _this->sym == LSS::_inst()->lparen )
				{
					LSS::_inst()->Get(_this->sym);
					_this->expression(clock);
					if( clock->type != LSB::_inst()->bitType )
						LSS::_inst()->Mark("clock must be bitType");
					
					if( (dynamic_cast<LSB::Object>(clock) != 0 ) && (clock->_to<LSB::Object>()->name == "clk") )
					{
						kind = 1;
						clock = 0;
					}
					if( _this->sym == LSS::_inst()->rparen )
						LSS::_inst()->Get(_this->sym);
					else
						LSS::_inst()->Mark("rparen ?");

				}else
				{
					LSS::_inst()->Mark("lparen expected");
					clock = _this->undef;
				}
				while( _this->sym == LSS::_inst()->ident )
					_this->VarList(kind, clock);
				
			}
		
		locals = _this->top->next;
		if( _this->sym == LSS::_inst()->begin )
		{
			LSS::_inst()->Get(_this->sym);
			_this->StatSequence();
		}
		/* find unassigned variables */
		obj = locals;
		_this->err = false;
		while( obj != LSB::_inst()->root )
		{
			if( (obj->tag == LSB::_inst()->var) && (obj->val < 5) )
			{
				if( (obj->b == 0) && (obj->val < 4) )
				{
					Texts::_inst()->WriteString(_this->W, obj->name);
					Texts::_inst()->Write(_this->W, ' ');
					_this->err = true;
				}else if( obj->b == _this->undef )
					obj->b = 0;
				
			}
			obj = obj->next;
		}
		if( _this->err )
		{
			Texts::_inst()->WriteString(_this->W, " unassigned");
			Texts::_inst()->WriteLn(_this->W);
		}else
		{
			/* find combinatorial loops */
			obj = locals;
			_this->err = false;
			while( obj != LSB::_inst()->root )
			{
				if( obj->tag == LSB::_inst()->var )
				{
					obj->marked = true;
					_this->Traverse(obj->b);
					obj->marked = false;
				}
				obj = obj->next;
			}
			if( _this->err )
			{
				Texts::_inst()->WriteString(_this->W, "in loop");
				Texts::_inst()->WriteLn(_this->W);
			}
		}
	}
	if( _this->err )
		Texts::_inst()->Append(Oberon::_inst()->Log, _this->W.buf);
	
	_this->top->next = oldtop;
	// END
}

void LSC::Module(Texts::Text T, int pos)
{
	// VAR
	LSB::Object root;
	_FxArray<char,32> modname;

	// BEGIN
	LSC* _this = _inst();
	Texts::_inst()->WriteString(_this->W, "compiling Lola: ");
	_this->bot = LSB::_inst()->root;
	_this->top->next = _this->bot;
	LSS::_inst()->Init(T, pos);
	LSS::_inst()->Get(_this->sym);
	if( _this->sym == LSS::_inst()->module )
	{
		LSS::_inst()->Get(_this->sym);
		if( _this->sym == LSS::_inst()->ident )
		{
			modname = LSS::_inst()->id;
			Texts::_inst()->WriteString(_this->W, LSS::_inst()->id);
			LSS::_inst()->Get(_this->sym);
			Texts::_inst()->WriteLn(_this->W);
			Texts::_inst()->Append(Oberon::_inst()->Log, _this->W.buf);
		}else
			LSS::_inst()->Mark("ident ?");

		_this->Unit(root);
		if( _this->sym == LSS::_inst()->ident )
		{
			LSS::_inst()->Get(_this->sym);
			if( LSS::_inst()->id != modname )
				LSS::_inst()->Mark("no match");
			
		}
		if( _this->sym != LSS::_inst()->period )
			LSS::_inst()->Mark("period ?");
		
		if( !LSS::_inst()->error )
			LSB::_inst()->Register(modname, root);
		else
		{
			Texts::_inst()->WriteString(_this->W, "compilation failed");
			Texts::_inst()->WriteLn(_this->W);
			LSB::_inst()->Register("", LSB::_inst()->root);
		}
	}else
		LSS::_inst()->Mark("module ?");

	Texts::_inst()->Append(Oberon::_inst()->Log, _this->W.buf);
	// END
}

void LSC::Compile()
{
	// VAR
	int beg;
	int end;
	int time;
	Texts::Scanner S;
	Texts::Text T;

	// BEGIN
	LSC* _this = _inst();
	Texts::_inst()->OpenScanner(S, Oberon::_inst()->Par.text, Oberon::_inst()->Par.pos);
	Texts::_inst()->Scan(S);
	if( S.class_ == Texts::_inst()->Char )
	{
		if( S.c == '*' )
			; // empty statement
		else if( S.c == '@' )
		{
			Oberon::_inst()->GetSelection(T, beg, end, time);
			if( time >= 0 )
				_this->Module(T, beg);
			
		}
	}else if( S.class_ == Texts::_inst()->Name )
	{
        T = new Texts::TextDesc(); // RK
		Texts::_inst()->Open(T, S.s);
		_this->Module(T, 0);
	}
	Texts::_inst()->Append(Oberon::_inst()->Log, _this->W.buf);
	// END
}

LSC::LSC()
{
	// BEGIN
	Texts::_inst()->OpenWriter(W);
	Texts::_inst()->WriteString(W, "Lola compiler; NW 27.8.2018");
	Texts::_inst()->WriteLn(W);
	factor = factor0;
	expression = expression0;
	Unit = Unit0;
	top = new LSB::ObjDesc();
	bot = LSB::_inst()->root;
	undef = new LSB::ObjDesc();
	undef->tag = LSB::_inst()->typ;
	undef->type = LSB::_inst()->bitType;
	undef->next = 0;
	// END
}

LSC::~LSC()
{
	s_inst.release();
}

